var sockjs = require('sockjs');
var _ = require('underscore');
var events = require('events');
var Request = require('./request');
var Response = require('./response');
var proto = require('./proto');

function createServer(){
    return new SocketServer();
}

function SocketServer(){
    //this is list of middleware
    //todo: need autoloading default middleware
    this.stack = [];

    //this is current id
    //all stream have unic id
    this.id = 0;

    //this is object with opened streams
    this.connection = {};

    //this is that determinate channelName and stream's id
    /*
     twitter: [15, 76, 78, 36],
     rs: [78, 36],
     */
    this.channelToClien = {};

    this.httpServer = null;

    //this is server channel
    //publish incoming message from clients and other
    //this channel listen all module, that interact with stream
    this.channel = new events.EventEmitter();

    this.sockjsServer = sockjs.createServer();
}
_.extend(SocketServer.prototype, proto, {
    start: function(httpServer){
        this.httpServer = httpServer;
        this.linkSocketConnection();
        this.bind();
    },

    linkSocketConnection: function(){
        //todo: prefix перенести в set опции
        this.sockjsServer.installHandlers(this.httpServer, {prefix:'/socket'});
    },
    bind: function(){
        var _this = this;
        this.sockjsServer.on("connection", function(stream){
            _this.onConnection(stream);
        });
    },
    onConnection: function(stream){
        var _this = this;
        this.incrementId();

        stream._id = _this.id;
        this.connection[ _this.id ] = stream;

        stream.on('data', function(message){
            _this.onData(message, stream);
        });

        stream.on('close', function(){
            _this.onCloseConn();
        });
    },

    onCloseConn: function(){
        console.log(this.connection);
    },

    onData: function( message, stream ){
        var data;

        try{
            data = JSON.parse(message);
        }catch(e){
            stream.write( JSON.stringify( this.error.invalidRequest ) );
        }

        //todo: добавить возможность middleware для запросов
        //todo: валидация RPC формата

        //determine what is it
        if( data.id ){
            if( data.method ){

                // strip trailing slash
                if ('/' == data.method[data.method.length - 1]) {
                    data.method = data.method.slice(0, -1);
                }

                //this is request (processing with middleware);
                var req = new Request(data);
                var res = new Response(data, stream);

                this.handle(req, res, null);

            }else if(data.result || data.error){
                //this is response
                //todo: implement processing response from client(s)
            }
        }else if (data.channel){
            //this is publish message
            this.channel.emit( data.channel, data.params );
        }

    },

    incrementId: function(){
        this.id++
    },

    error: {
        "invalidRequest": {"error": {"code": 1, "message": "Invalid Request"}, "id": null}
    }

});

module.exports = createServer;

//-------------------------------------------------------


function WebSocketServer(server, crossroads){
    this.connection = [];

    //save all middleware
    this.stack = [];

    this.httpServer = server;
    this.crossroads = crossroads;

    this.init();
}

WebSocketServer.prototype = {
    init: function(){
        var _this = this;

        this.sockjsServer = sockjs.createServer();
        this.sockjsServer.installHandlers(this.httpServer, {prefix:'/socket'});

        this.sockjsServer.on("connection", function(conn){
            _this.onConnection(conn);
        });
    },

    onConnection: function(conn){

        var _this = this;
        this.connection.push(conn);

        conn.on('data', function(message){
            _this.onData(message, conn);
        });

        conn.on('close', function(){
            _this.onCloseConn();
        });
    },

    onData: function( message, conn ){
        var data;

        try{
            data = JSON.parse(message);
        }catch(e){
            conn.write( JSON.stringify( this.error.invalidRequest ) );
        }

        //todo: добавить возможность middleware для запросов
        //todo: валидация RPC формата

        //determine what is it
        if( data.id ){
            if( data.method ){
                //this is request (send to routing);
                var req = this.createRequest( data, conn );
                this.crossroads.parse( req.method, [req.res, req, req.next]  );

            }else if(data.result || data.error){
                //this is response
                //todo: implement processing response from client(s)
            }
        }else if (data.channel){
            //this is publish message
            serverChannel.emit( data.channel, data.data );
        }

    },

    createRequest: function(data, conn){



        var req = new Request(data.method, data.params, data.id, conn);
        _.bind(req.res.getData, req);
        _.bind(req.next, req);
        return req;
    },

    onCloseConn: function(){},

    error: {
        "cannotParseMessage": {"error": {"code": 1, "message": "Cannot Parse Message"}, "id": null},
        "unhandledError": {
            "error": {"code": 2, "message": "unhandled Error"},
             "id": null
         }
    }

}

