var _ = require('underscore'),
    fs = require('fs'),
    async = require('async'),
    config = require('config'),
    Utility = require('libs/utility'),
    path = require('path');

var root = "./public";

function FsWorker(){}
_.extend(FsWorker.prototype, {

    //public
    exists: function(path, callback){
        fs.exists(path, function (exists) {
            if(exists){
                callback(null, true);
            }else{
                callback(null, false);
            }
        });
    },

    existsList: function(paths, callback){
        async.map(paths, this.exists, function(err, results){
            if(err) return callback(err);
            callback(null, results);
        });
    },

    /**
     * get all file and folder from dir
     * @param dir {String}
     * @param cb {Function}
     * */
    listDir: function(dir, cb){
        fs.readdir(dir, function(err, list){
            if (err) return cb(err);
            cb(null, list);
        });
    },

    /**
     * get all file and folder from dir with file info
     * @param dir {String} String like '/img/blog'
     * @param cb {Function} This is callback
     **/
    listDirWithInfo: function(dir, cb){
        var _this = this;
        this.listDir(dir, function(err, list){
            if (err) return cb(err);
            _this._listDirWithInfo( list, dir, cb )
        });
    },

    /**
     * @param list {Array} Array with name files
     * @param dir {String} String like '/img/blog'
     * @param cb {Function} This is callback
     * */
    _listDirWithInfo: function(list, dir, cb){

        var pending = list.length;
        var results = [],
            _this = this;
        if (!pending) return cb(null, results);

        list.forEach(function(file){

            var filePath = dir + "/" + file;

            _this.getStat(filePath, function(err, stat){
                if (err) return cb(err);
                stat['path'] = Utility.clearRoot(filePath);
                stat['name'] = file;
                stat['isDirectory'] = stat.isDirectory();
                results.push(stat);
                if (!--pending) cb(null, results);
            });
        });

    },

    //Создать папку рекурсивно
    makeDir: function(dirPath, mode, callback, position){

        var mode = mode || 0777,
            position = position || 0,
            parts = dirPath.split('/'),
            _this = this;

        parts = parts.filter(function(val) {
            if( val ) return val;
        })

        if (position >= parts.length) {
            if (callback) {
                return callback();
            } else {
                return true;
            }
        }

        var directory = parts.slice(0, position + 1).join('/');

        fs.stat(directory, function(err) {
            if (err === null) {
                _this.makeDir(dirPath, mode, callback, position + 1);
            } else {
                fs.mkdir(directory, mode, function (err) {
                    if (err) {
                        if (callback) {
                            return callback(err);
                        } else {
                            throw err;
                        }
                    } else {
                        _this.makeDir(dirPath, mode, callback, position + 1);
                    }
                })
            }
        })
    },

    /**
     * Delete folder recursive
     * @param pathItem{String} String like '/img/blog'
     * @param callback {Function}
     * */
    removeDir: function(pathItem, callback){
        var _this = this;

        async.waterfall([

            //check path
            function(callback){
                _this.exists(pathItem, function(err, exists){
                    if(err) callback(err);
                    callback(null, exists);
                });
            },

            //get stats
            function(exists, callback){

                if(!exists) callback( new Error("Path is not found") );

                _this.getStat(pathItem, function(err, stats){
                    if(err) callback(err);
                    callback(null, stats);
                })
            },

            //remove item
            function( stats, callback ){

                if( stats.isFile() ){
                    //this is file, remove file

                    fs.unlink(pathItem, function(err){
                        if(err) callback(err);
                        //stop execute
                        callback(true);
                    });
                }else if( stats.isDirectory() ) {
                    //this is directory, need scan and remove directory
                    _this.listDirWithInfo(pathItem, function(err, list){
                        if(err) callback(err);
                        callback(null, list);
                    })
                }
            },

            function(list, callback){

                var count = list.length;
                if( !count ) callback(true);

                var iterator = 0;

                list.forEach(function(file){
                    var internalPath = pathItem + "/" + file;

                    _this.getStat(internalPath, function(err, stats){
                        if(err) callback(err);

                        if( stats.isFile() ){
                            //this is file, remove file

                            fs.unlink(pathItem, function(err){
                                if(err) callback(err);
                                iterator++;
                                if(iterator === count) {
                                    callback(null);
                                }
                            });
                        }else{
                            //this is directory, need scan and remove directory
                            _this.removeDir(pathItem, function(err){
                                if(err) callback(err);
                                iterator++;
                                if(iterator === count) {
                                    callback(null);
                                }
                            })
                        }
                    })
                })
            }

        ], function(err){
            if(err){
                if( err === true ){
                    callback(null);
                }else{
                    callback(err);
                }
            }

            callback(null);
        })

        /*if( fs.existsSync(pathItem) ) {

         if(!fs.statSync(fullPath).isDirectory()){
         fs.unlinkSync(fullPath);
         }else {
         fs.readdirSync(fullPath).forEach(function(file, index){

         var curPath = fullPath + "/" + file;

         if(fs.statSync(curPath).isDirectory()) {
         _this.removeDir(pathItem + "/" + file);
         } else {
         fs.unlinkSync(curPath);
         }
         });
         fs.rmdirSync(fullPath);
         }

         }*/
    },

    /*removeDir: function(pathItem){
     var _this = this;
     var fullPath = root + pathItem;

     if( fs.existsSync(fullPath) ) {

     if(!fs.statSync(fullPath).isDirectory()){
     fs.unlinkSync(fullPath);
     }else {
     fs.readdirSync(fullPath).forEach(function(file, index){

     var curPath = fullPath + "/" + file;

     if(fs.statSync(curPath).isDirectory()) {
     _this.removeDir(pathItem + "/" + file);
     } else {
     fs.unlinkSync(curPath);
     }
     });
     fs.rmdirSync(fullPath);
     }

     }
     },*/

    //Удалить папки рекурсивно
    removeDirs: function(paths, callback){
        var _this = this;

        _.each(paths, function(currentPath){
            _this.removeDir(currentPath, function(err){
                if(err) callback(err);
                callback(null);
            });
        })
    },

    //renameFolder
    rename: function(dirPath, newName, cb){
        var parts = dirPath.split('/').filter(function(val) {if( val ) return val;});
        var oldName = parts.pop();

        var oldPath = root + "/" + parts.join('/') + "/" + oldName;
        var newPath = root + "/" + parts.join('/') + "/" + newName;
        fs.rename(oldPath, newPath, cb)
    },

    _clearRoot: function(filePath){
        return filePath.replace(root,"");
    },

    getStat: function(path, cb){
        fs.stat(path, cb);
    }
})
/*var fsWoker = new FsWorker();

 fsWoker.listDir('/img/blog/default/123', function(err, list){
 });*/

module.exports = FsWorker;

/*

 fsWoker.rename('/some/New Text Document.txt', "newName", function(err){
 console.log(err)
 });

 fsWoker.rename('/some/test/rename', "newName", function(err){
 console.log(err)
 });

 fsWoker.removeDir('/some');

 fsWoker.makeDir('/some/test/plugins');

 fsWoker.listDir("/", function(err, done){
 console.log(err);
 console.log(done);
 })

 fsWoker.listDirWithInfo("/", function(err, done){
 console.log(err);
 console.log(done);
 })

 */