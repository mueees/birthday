var sockjs = require('sockjs');
var _ = require('underscore');
var events = require('events');
var Request = require('./request');
var Response = require('./response');
var proto = require('./proto');

function createServer(){
    return new SocketServer();
}

function SocketServer(){
    //this is list of middleware
    //todo: need autoloading default middleware
    this.stack = [];

    //this is current id
    //all stream have unic id
    this.id = 0;

    //this is object with opened streams
    this.connection = {};

    //this is that determinate channelName and stream's id
    /*
     twitter: [15, 76, 78, 36],
     rs: [78, 36],
     */
    this.channelToClient = {};

    this.httpServer = null;

    //this is server channel
    //publish incoming message from clients and other
    //this channel listen all module, that interact with stream
    this.channel = new events.EventEmitter();

    this.sockjsServer = sockjs.createServer();

    _.bindAll(this, "sendMessageToClientChannel");

}
_.extend(SocketServer.prototype, proto, {

    start: function(httpServer){
        this.httpServer = httpServer;
        this.linkSocketConnection();
        this.bind();
    },

    linkSocketConnection: function(){
        //todo: prefix перенести в set опции
        this.sockjsServer.installHandlers(this.httpServer, {prefix:'/socket'});
    },

    bind: function(){
        var _this = this;
        this.bindToChannel();
        this.sockjsServer.on("connection", function(stream){
            _this.onConnection(stream);
        });
    },

    onConnection: function(stream){
        var _this = this;
        this.incrementId();

        stream._id = _this.id;
        this.connection[ _this.id ] = stream;

        stream.on('data', function(message){
            _this.onData(message, stream);
        });

        stream.on('close', function(){
            _this.onCloseConn();
        });
    },

    onCloseConn: function(){
        console.log(this.connection);
    },

    onData: function( message, stream ){
        var _this = this;
        var data;

        try{
            data = JSON.parse(message);
        }catch(e){
            stream.write( JSON.stringify( this.error.invalidRequest ) );
        }

        //todo: добавить возможность middleware для запросов
        //todo: валидация RPC формата

        //determine what is it
        if( data.id ){
            if( data.method ){

                // strip trailing slash
                if ('/' == data.method[data.method.length - 1]) {
                    data.method = data.method.slice(0, -1);
                }

                //this is request (processing with middleware);
                var req = new Request(data);
                var res = new Response(data, stream);

                this.handle(req, res, null);

            }else if(data.result || data.error){
                //this is response
                //todo: implement processing response from client(s)
            }
        }else if (data.channel){
            //this is publish message
            this.channel.emit( data.channel, data.params );
        }

    },

    bindToChannel: function(){
        this.channel.on("toClientChannel", this.sendMessageToClientChannel)
    },

    sendMessageToClientChannel: function(data){

        var _this = this;
        if( !this.channelToClient[data.channel]) return false;

        var streamIds = this.channelToClient[data.channel];
        if( !streamIds ) return false;

        streamIds.forEach(function(streamId){
            _this.connection[streamId].write( JSON.stringify(data) );
        })
    },

    incrementId: function(){
        this.id++
    },

    error: {
        "invalidRequest": {"error": {"code": 1, "message": "Invalid Request"}, "id": null}
    }

});

module.exports = createServer;